---
title: Bivariate DHGLM isotopes in voles and mice (population-level)
date: August 15, 2024
author:  Federico Garrido
format:
  html:
    toc: true
    html-math-method: katex
    css: styles.css
embed-resources: true
toc: true
---


## General Aim

Use a bivariate DHGLM to analyse many populations of two two sps (voles and mices) separately data and compare the approach with other data set here focusing only on the population data in different sites. Here, we'll extract the blups and plot mean and variance for C and N isotopes.Then, estimate the repeatability (R2). 

## MODEL FORMULA FOR POPULATION-LEVEL ANALYSIS

```{r}
#| label: setup
#| message: false
#| include: false
library(brms)
library(purrr)
library(tidyverse)
library(patchwork)
```

```{r}
#| label: data
#| message: false
#| include: true
DF<-read.csv("MINAKI.csv", header = T, sep = ";", stringsAsFactors = T, dec=",")
DF$year <- as.factor(DF$year)
DF$d13C <- scale(DF$d13C)
DF$d15N <- scale(DF$d15N)

MG1<- subset(DF, species=="MG")
str(MG1)
MG1$date <- scale(as.numeric(MG1$date))
mean(MG1$date)

PM1<- subset(DF, species=="PM")
PM1$date <- scale(as.numeric(PM1$date))
str(PM1)
mean(PM1$date)

```

```{r}
#| label: model for Myodes gapperi (voles)  
#| message: false
#| include: true
#| 
#form1<- bf(d13C ~ date + site_type2 + (1|a|site)) + lf (sigma ~ date + site_type2 + (1|a|site))
#form2<- bf(d15N ~ date + site_type2 + (1|a|site)) + lf (sigma ~ date + site_type2 + (1|a|site))

#fit1 <- brm(formula = form1 + form2, data = MG1,iter = 8000, chains = 4, thin = 10, cores = 4)
  #summary(fit1)
#### Save the model
 #saveRDS(fit1, file = "minaki_MG.rds")
model1 <- readRDS("minaki_MG.rds")
summary(model1)

```


## First Aim: exctract and plot BLUPs

## Data
231 samples for Myodes gapperi (voles) and 254 samples for Peromyscus maniculatus (mice) collected over a 3-year period (mostly in 2014 and 2015) on 18 sites (12 islands and 6 mainland sites)

#### About the blups and general formula to extract them

Y: a + bx + Î±m + e, where Î±m are the blups
Ve : exp (c + dx + Î±v) where Î±v are the blups
To extract the residual individual variance to each individual (Isd): âˆš(exp(c+ Î±v))
Then, to plot the individual mean of C and N with their individual variance for each individual:
Im â€“ Isd, Im + Isd
obj[1] = c, the intercept of the dispersion model; obj[2] = d, the slope for the centered date (multiplied by 0 because mean date = 0); obj[3] = Î±_v, the individual BLUP for the dispersion part

```{r}
#| label: exctracting blups
#| message: false
#| include: false
#| # Extract fixed effects C and N
## Function to extract blups and then ggplot to plot them

### all in a function
  fn_int <- function(obj) {
    out <- obj[1] + obj[2]*0 + obj[3] / 2 # mean_date = zero because date is centered
    out
  }
plot_blups <- function(model){
  fix_coef <- fixef(model, summary = TRUE)[, 1]

  int_d13C <- select(data.frame(t(fix_coef)), starts_with("d13C")) %>%
    fn_int() %>%
    unlist()

  int_d15N <- select(data.frame(t(fix_coef)), starts_with("d15N")) %>%
    fn_int() %>%
    unlist()

  sig_d13C <- select(data.frame(t(fix_coef)), starts_with("sigma_d13C")) %>%
    fn_int() %>%
    unlist()

  sig_d15N <- select(data.frame(t(fix_coef)), starts_with("sigma_d15N")) %>%
    fn_int() %>%
    unlist()

  # Exctract BLUPs from random effects
  blup <- ranef(model, summary = TRUE)$site
  blups <- blup[, 1, 1:4]

  bl_fix <- data.frame(blups) %>%
    mutate(
      int_d13C = d13C_Intercept + int_d13C,
      sig_d13C = sqrt(exp(sigma_d13C_Intercept + sig_d13C)),
      int_d15N = d15N_Intercept + int_d15N,
      sig_d15N = sqrt(exp(sigma_d15N_Intercept + sig_d15N))
    )

  ggplot(bl_fix, aes(x = int_d13C, y = int_d15N)) +
    geom_point() +
    geom_errorbar(aes(
      xmin = int_d13C - sig_d13C, xmax = int_d13C + sig_d13C
    ), color = "darkblue") +
    geom_errorbar(aes(
      ymin = int_d15N - sig_d15N, ymax = int_d15N + sig_d15N
    ), color = "coral") +
    xlab("d13C") + 
    ylab("d15N") +
    theme_classic()+
    theme(axis.title.x = element_text(size = 25, face = "bold"), #tama?o de titulo ejes
          axis.title.y = element_text(size = 25, face = "bold"))+
    theme(axis.text = element_text(size = 18))
}

## end of functions
```


```{r}
#| label: rep-plot

## making plots
pMG <- plot_blups(model1) + ggtitle("Myodes gapperi") + theme(plot.title = element_text(size = 25))
pMG

ggsave("pMG.png", width = 13, height = 10)

```

## Estimate Repeatability

```{r}
#| label: functions

repeatt <- function(model){
  vars <- VarCorr(model, summary = FALSE)$site$sd^2 %>%
    as.data.frame()  %>%
    rename_with(~ gsub("Intercept", "var", .x, fixed = TRUE))

vr_exp <- fixef(model, summary = FALSE) %>%
  data.frame()%>%
  select(starts_with("sigma"))

sig_d13C <- select(vr_exp, starts_with("sigma_d13C")) %>%
  fn_int() %>%
  rename(sig_d13C = "sigma_d13C_Intercept")
sig_d15N <- select(vr_exp, starts_with("sigma_d15N")) %>%
  fn_int() %>%
    rename(sig_d15N = "sigma_d15N_Intercept")

var_pd <- data.frame(vars)  %>%
  cbind(sig_d13C) %>%
  cbind(sig_d15N) %>%
  mutate(
    v_r_c = exp(sig_d13C + sigma_d13C_var / 2),
    v_r_n = exp(sig_d15N + sigma_d15N_var / 2),
    r2_c = d13C_var / (d13C_var + v_r_c),
    r2_n = d15N_var / (d15N_var + v_r_n)
  )
}

# end of the function
```

```{r}
#| label: save R2
#| echo: false

RMG <- repeatt(model1)
mean_MG <- sapply(RMG, mean)
show(mean_MG)
write.csv(mean_MG, "R2_MG.csv", row.names=T) 
```


## Second Aim: correlation ellipses

Plot the ellipses of the correlations between C and N (intercept and sigma intercept) for multiple populations of red-backed voles 

## Plot correlation parameters for A. australis (fur seals)

```{r}
#| label: setup and load data
#| message: false
#| include: false
#| 
library(brms)
library(ellipse) # for ellipse estimation
library(tidyverse)
library(patchwork)

model <- readRDS("minaki_MG.rds")
summary(model)
DF <- read.csv("MINAKI.csv", header = T, sep = ";", stringsAsFactors = T, dec = ",")
AA <- subset(DF, species == "MG")
```

Correlation parameters for the variance components of the models, showing the relationship between the mean inter-unit variation (inter-unit var) and the variation in residuals within each unit (within-unit var) for ð›¿Â¹Â³C and ð›¿15N values.

```{r}
#| label: extracting values
#| message: false
#| include: true
#| 
blup <- ranef(model)$site[, 1, ] %>% data.frame() %>%
  rename_with(~ gsub("_Intercept", "", .x, fixed = TRUE))

vars <- VarCorr(model, summary = FALSE)$site$cov %>%
    as.data.frame() %>%
    rename_with(~ gsub("_Intercept", "", .x, fixed = TRUE))
```


```{r}
#| label: extract values and plot
#| message: false
#| include: false
# Function to extract the values. Generate and plot for ellipses.
# function to generate ellipses and plot them - extracting value of var covar matrix for a given random effect
plot_blup_ell <- function(v, df_blups, coefs, n_ell, alpha_ell = 0.05,
                          x_axs, y_axs, title, axs_lim) {
  # define variance components based on coefs to plot
  v_est <- vars %>%
    select(
      paste(coefs[1], coefs[1], sep = "."),
      paste(coefs[1], coefs[2], sep = "."),
      paste(coefs[2], coefs[1], sep = "."),
      paste(coefs[2], coefs[2], sep = ".")
      )

  # Number and selection of posterior draws
  n_boot <- ifelse(!missing(n_ell), n_ell, nrow(v_est))
  samples <- sample(seq_len(nrow(v_est)), n_boot, replace = FALSE)

  # Number of points wanted for each ellipse
  n_ellpoints <- 100

  # Make an ellipse of the estimated matrix v_est
  # (here using column means)

  df_ell <- as_tibble(ellipse::ellipse(matrix(colMeans(v_est), 2, 2), npoints = n_ellpoints)) # using ellipse from ellipse library not car library

  # Set up empty data frame for ellipse paths for each PD
  df_bootell <- tibble(
    Replicate = numeric(0),
    x = numeric(0),
    y = numeric(0)
  )

  # loop to estimate ellipses
  for (i in samples) {
    # Create temporary matrix of this draw
    mat_tmp <- matrix(unlist(v_est[i, ]), 2, 2)
    # Create temporary data frame of ellipse points for this draw
    df_tmp <- cbind(
      Replicate = rep(i, n_ellpoints),
      as_tibble(ellipse::ellipse(mat_tmp, npoints = n_ellpoints))
    )

    # Bind points to the ellipse df
    df_bootell <- bind_rows(df_bootell, df_tmp)
  }

  gg_blup_ellipse <- ggplot() +
    geom_hline(
      yintercept = 0, colour = "grey30", alpha = 0.4, linetype = "dotted"
    ) +
    geom_vline(
      xintercept = 0, colour = "grey30", alpha = 0.4, linetype = "dotted"
    ) +
    geom_path(
      data = df_bootell,
      aes(
        x = x,
        y = y,
        group = factor(Replicate)
      ), colour = "grey50", alpha = alpha_ell
    ) +
    geom_path(
      data = df_ell,
      aes(
        x = x,
        y = y
      ),
      size = 1.2
    ) +
    geom_point(
      data = df_blups,
      aes(x = .data[[coefs[1]]], y = .data[[coefs[2]]]), alpha = 0.4
    )  +
    xlim(-axs_lim, axs_lim) +
    ylim(-axs_lim, axs_lim) +
    labs(
      x = x_axs,
      y = y_axs,
    ) +
    theme_classic(base_size = 10) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"),
        axis.text = element_text(size = 18),
        axis.title = element_text(size = 25, face = "bold")
      )

  # Have a look
  gg_blup_ellipse
}

## end of functions
```

## Plotting the 6 correlations C and N: Black ellipses represent the average covariance, while grey thin ellipses represent covariance from different posterior samples to illustrate the estimation error.Black points show the predicted mean values of the random effects (Best Linear Unbiased Predictors, BLUPs) for each sampled ellipse.

```{r}
#| label: replot
#| message: false
#| warning: false
#| include: false

p1 <- plot_blup_ell(vars, blup, c("d13C", "d15N"), 200,
  x_axs = "d13C",
  y_axs = "d15N",
  axs_lim = 4.5)
p1

p2 <- plot_blup_ell(vars, blup, c("d13C", "sigma_d15N"), 200,
  x_axs = "d13C",
  y_axs = "sigma d15N",
  axs_lim = 4.5)

p3 <- plot_blup_ell(vars, blup, c("d13C", "sigma_d13C"), 200,
                    x_axs = "d13C",
                    y_axs = "sigma d13C",
                    axs_lim = 4.5)

p4 <- plot_blup_ell(vars, blup, c("sigma_d13C", "d15N"), 200,
                    x_axs = "sigma_d13C",
                    y_axs = "d15N",
                    axs_lim = 4.5)

p5 <- plot_blup_ell(vars, blup, c("sigma_d13C", "sigma_d15N"), 200,
                    x_axs = "sigma_d13C",
                    y_axs = "sigma_d15N",
                    axs_lim = 4.5)

p6 <- plot_blup_ell(vars, blup, c("d15N", "sigma_d15N"), 200,
                    x_axs = "d15N",
                    y_axs = "sigma_d15N",
                    axs_lim = 4.5)

```

```{r}
#| label: seteo4
#| message: false
#| include: true

AA_plot <- (p1+p2+p3+p4+p5+p6)
AA_plot
ggsave("MG_plot.png", width = 13, height = 10)
```