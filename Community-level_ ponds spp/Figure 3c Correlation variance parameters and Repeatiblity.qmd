---
title: Bivariate DHGLM isotopes (Community-level)
date: August 16, 2024
author:  Federico Garrido & Julien Martin
format: html
html:
embed-resources: true
toc: true
warning: false
---

## General Aim

Use a bivariate DHGLM to analyse one community pond data and compare the approach with other data set here focusing only on the community data. Here, we'll extract the blups and plot de individual mean and variance for C and N isotopes.Then, estimate the repeatability (R2)

## First Aim: exctract and plot BLUPs from the model

```{r}
#| label: setup
#| message: false
#| include: false
library(brms)
library(purrr)
library(tidyverse)
library(patchwork)
```

## Load and check the data

```{r}
#| label: load
dat <- read.table("StableIsotope_clean_jm.csv",
  header = TRUE,
  sep = ";",
  dec = "."
) %>%
  rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) %>%
  select(species:noindiv, drymass, bodyl, d13c, d15n) %>%
  filter(location == "DC108_1") %>%
  drop_na(d15n, drymass)  %>%
  mutate(
    mass_sc = scale(drymass),
    d13C = scale(d13c),
    d15N = scale(d15n)
  )

str(dat)

```

## Model

```{r}
#| label: model1
#| eval: false
form_c <- bf(d13c ~ (1 | a | species)) + lf(sigma ~ (1 | a | species))

form_n <- bf(d15n ~ (1 | a | species)) + lf(sigma ~ (1 | a | species))

# # fit2 <- brm(
#   formula = form_c + form_n + set_rescor(TRUE),
#   data = dat,
#   iter = 4000,
#   chains = 4, thin = 10,
#   cores = 4
# )

# saveRDS(fit2, "community_model.rds")
fit2 <- readRDS("community_model.rds")
summary(fit2)

```

## First Aim: exctract and plot BLUPs

#### About the blups and general formula to extract them

fn_int(): extracts only the intercept (c) from the dispersion model.
In this model the residual variance is:Ve = exp(c + Œ±_v)
Since there are no additional predictors in the dispersion part, the expected residual variance depends only on the intercept c.
Therefore, fn_int(obj) = obj[1]. = c, the intercept of the dispersion model; obj[2] = d, the slope for the centered date (multiplied by 0 because mean date = 0); obj[3] = Œ±_v, the individual BLUP for the dispersion part

```{r}
#| label: functions
#| include: false

# FUNCTIONS

### all in a function
fn_int <- function(obj) {
  out <- obj[1]
  out
}

plot_blups <- function(model) {
  fix_coef <- fixef(model, summary = TRUE)[, 1]

  int_d13C <- select(data.frame(t(fix_coef)), starts_with("d13c")) %>%
    fn_int() %>%
    unlist()

  int_d15N <- select(data.frame(t(fix_coef)), starts_with("d15n")) %>%
    fn_int() %>%
    unlist()

  sig_d13C <- select(data.frame(t(fix_coef)), starts_with("sigma_d13c")) %>%
    fn_int() %>%
    unlist()

  sig_d15N <- select(data.frame(t(fix_coef)), starts_with("sigma_d15n")) %>%
    fn_int() %>%
    unlist()

  # Extraer los BLUPs de los efectos aleatorios
  blup <- ranef(model, summary = TRUE)$species
  blups <- blup[, 1, 1:4]

  bl_fix <- data.frame(blups) %>%
    mutate(
      int_d13C = d13c_Intercept + int_d13C,
      sig_d13C = sqrt(exp(sigma_d13c_Intercept + sig_d13C)),
      int_d15N = d15n_Intercept + int_d15N,
      sig_d15N = sqrt(exp(sigma_d15n_Intercept + sig_d15N))
    )

  ggplot(bl_fix, aes(x = int_d13C, y = int_d15N)) +
    geom_point() +
    geom_linerange(aes(
      xmin = int_d13C - sig_d13C, xmax = int_d13C + sig_d13C
    ), color = "darkblue") +
    geom_linerange(aes(
      ymin = int_d15N - sig_d15N, ymax = int_d15N + sig_d15N
    ), color = "coral") +
    xlab("d13C") +
    ylab("d15N") +
#    xlim(-17, -12) +
#    ylim(14, 22) +
    theme_classic()+
    theme(axis.title.x = element_text(size = 25, face = "bold"), #tama?o de titulo ejes
          axis.title.y = element_text(size = 25, face = "bold"))+
    theme(axis.text = element_text(size = 18))
}


```

## Plots and Repeatibility
```{r}
#| label: rep-plot
#| include: true


fn_rep <- function(model) {
  vars <- VarCorr(fit2, summary = FALSE)$species$sd^2 %>%
    as.data.frame() %>%
    rename_with(~ gsub("Intercept", "var", .x, fixed = TRUE))

  vr_exp <- fixef(fit2, summary = FALSE) %>%
    data.frame() %>%
    select(starts_with("sigma"))

  sig_d13C <- select(vr_exp, starts_with("sigma_d13c")) %>%
    fn_int() %>%
    rename(sig_d13C = "sigma_d13c_Intercept")
  sig_d15N <- select(vr_exp, starts_with("sigma_d15n")) %>%
    fn_int() %>%
    rename(sig_d15N = "sigma_d15n_Intercept")

  var_pd <- data.frame(vars) %>%
    cbind(sig_d13C) %>%
    cbind(sig_d15N) %>%
    mutate(
      v_r_c = exp(sig_d13C + sigma_d13c_var / 2),
      v_r_n = exp(sig_d15N + sigma_d15n_var / 2),
      r2_c = d13c_var / (d13c_var + v_r_c),
      r2_n = d15n_var / (d15n_var + v_r_n)
    )

  summary(as.mcmc(var_pd), quantile = c(0.025, 0.975))
}


comm_plot<-plot_blups(fit2)  + ggtitle("Community-level")+ theme(plot.title = element_text(size = 25))
show(comm_plot)

ggsave("comm_plot.png", width = 13, height = 10)


comm_level<- fn_rep(fit2)
comm_level1<- comm_level[["statistics"]]
show(comm_level1)
write.csv(comm_level1, "comm_level1.csv", row.names=T) 

```

## Second Aim: correlation ellipses

Plot the ellipses of the correlations between C and N (intercept and sigma intercept) for multiple spp in a pond community

```{r}
#| label: setup1
#| message: false
#| include: false
#| 
library(brms)
library(ellipse) # for ellipse estimation
library(tidyverse)
library(patchwork)

```

```{r}
#| label: load data
#| message: false
#| include: true

model1 <- readRDS("community_model.rds")

dat <- read.table("StableIsotope_clean_jm.csv",
                  header = TRUE,
                  sep = ";",
                  dec = ".") %>%
  rename_with(~ tolower(gsub(".", "_", .x, fixed = TRUE))) %>%
  select(species:noindiv, drymass, bodyl, d13c, d15n) %>%
  filter(location == "DC108_1") %>%
  drop_na(d15n, drymass)  %>%
  mutate(
    mass_sc = scale(drymass),
    d13C = scale(d13c),
    d15N = scale(d15n))
```

Correlation parameters for the variance components of the models, showing the relationship between the mean inter-unit variation (inter-unit var) and the variation in residuals within each unit (within-unit var) for ùõø¬π¬≥C and ùõø15N values.

```{r}
#| label: exctract BLUPs and var-cov values
#| message: false
#| include: true
#| 
blup <- ranef(model1)$species[, 1, ] %>% data.frame() %>%
  rename_with(~ gsub("_Intercept", "", .x, fixed = TRUE))

vars <- VarCorr(model1, summary = FALSE)$species$cov %>%
  as.data.frame() %>%
  rename_with(~ gsub("_Intercept", "", .x, fixed = TRUE))
```


```{r}
#| label: Generate ellipses
#| message: false
#| include: false
#| # Function to extract the values. Generate and plot for ellipses.
# function to generate ellipses and plot them - extracting value of var covar matrix for a given random effect
plot_blup_ell <- function(v, df_blups, coefs, n_ell, alpha_ell = 0.05,
                          x_axs, y_axs, title, axs_lim) {
  # define variance components based on coefs to plot
  v_est <- vars %>%
    select(
      paste(coefs[1], coefs[1], sep = "."),
      paste(coefs[1], coefs[2], sep = "."),
      paste(coefs[2], coefs[1], sep = "."),
      paste(coefs[2], coefs[2], sep = ".")
      )

  # Number and selection of posterior draws
  n_boot <- ifelse(!missing(n_ell), n_ell, nrow(v_est))
  samples <- sample(seq_len(nrow(v_est)), n_boot, replace = FALSE)

  # Number of points wanted for each ellipse
  n_ellpoints <- 100

  # Make an ellipse of the estimated matrix v_est
  # (here using column means)

  df_ell <- as_tibble(ellipse::ellipse(matrix(colMeans(v_est), 2, 2), npoints = n_ellpoints)) # using ellipse from ellipse library not car library

  # Set up empty data frame for ellipse paths for each PD
  df_bootell <- tibble(
    Replicate = numeric(0),
    x = numeric(0),
    y = numeric(0)
  )

  # loop to estimate ellipses
  for (i in samples) {
    # Create temporary matrix of this draw
    mat_tmp <- matrix(unlist(v_est[i, ]), 2, 2)
    # Create temporary data frame of ellipse points for this draw
    df_tmp <- cbind(
      Replicate = rep(i, n_ellpoints),
      as_tibble(ellipse::ellipse(mat_tmp, npoints = n_ellpoints))
    )

    # Bind points to the ellipse df
    df_bootell <- bind_rows(df_bootell, df_tmp)
  }

  gg_blup_ellipse <- ggplot() +
    geom_hline(
      yintercept = 0, colour = "grey30", alpha = 0.4, linetype = "dotted"
    ) +
    geom_vline(
      xintercept = 0, colour = "grey30", alpha = 0.4, linetype = "dotted"
    ) +
    geom_path(
      data = df_bootell,
      aes(
        x = x,
        y = y,
        group = factor(Replicate)
      ), colour = "grey50", alpha = alpha_ell
    ) +
    geom_path(
      data = df_ell,
      aes(
        x = x,
        y = y
      ),
      size = 1.2
    ) +
    geom_point(
      data = df_blups,
      aes(x = .data[[coefs[1]]], y = .data[[coefs[2]]]), alpha = 0.4
    )  +
    xlim(-axs_lim, axs_lim) +
    ylim(-axs_lim, axs_lim) +
    labs(
      x = x_axs,
      y = y_axs,
    ) +
    theme_classic(base_size = 10) +
      theme(
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(colour = "black"),
        axis.text = element_text(size = 18),
        axis.title = element_text(size = 25, face = "bold")
      )

  # Have a look
  gg_blup_ellipse
}

## end of functions
```

## ## Plotting the 6 correlations C and N
Black ellipses represent the average covariance, while grey thin ellipses represent covariance from different posterior samples to illustrate the estimation error.Black points show the predicted mean values of the random effects (Best Linear Unbiased Predictors, BLUPs) for each sampled ellipse.

```{r}
#| label: rep-plot1

p1 <- plot_blup_ell(vars, blup, c("d13c", "d15n"), 200,
  x_axs = "d13C",
  y_axs = "d15N",
  axs_lim = -9)

p2 <- plot_blup_ell(vars, blup, c("d13c", "sigma_d15n"), 200,
  x_axs = "d13C",
  y_axs = "sigma d15N",
  axs_lim = -9)

p3 <- plot_blup_ell(vars, blup, c("d13c", "sigma_d13c"), 200,
                    x_axs = "d13C",
                    y_axs = "sigma d13C",
                    axs_lim = -9)


p4 <- plot_blup_ell(vars, blup, c("sigma_d13c", "d15n"), 200,
                    x_axs = "sigma_d13C",
                    y_axs = "d15N",
                    axs_lim = -9)


p5 <- plot_blup_ell(vars, blup, c("sigma_d13c", "sigma_d15n"), 200,
                    x_axs = "sigma_d13C",
                    y_axs = "sigma_d15N",
                    axs_lim = -9)


p6 <- plot_blup_ell(vars, blup, c("d15n", "sigma_d15n"), 200,
                    x_axs = "d15N",
                    y_axs = "sigma_d15N",
                    axs_lim = -9)


comm_plot <- (p1+p2+p3+p4+p5+p6)
comm_plot
ggsave("comm_plot.png", width = 13, height = 10)

```